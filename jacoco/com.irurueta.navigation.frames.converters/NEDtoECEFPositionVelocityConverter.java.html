<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NEDtoECEFPositionVelocityConverter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.frames.converters</a> &gt; <span class="el_source">NEDtoECEFPositionVelocityConverter.java</span></div><h1>NEDtoECEFPositionVelocityConverter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.frames.converters;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFPosition;
import com.irurueta.navigation.frames.ECEFVelocity;
import com.irurueta.navigation.frames.NEDFrame;
import com.irurueta.navigation.frames.NEDPosition;
import com.irurueta.navigation.frames.NEDVelocity;
import com.irurueta.navigation.geodesic.Constants;

/**
 * Converts curvilinear to cartesian position and velocity resolving
 * axes from NED to ECEF.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multi-sensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * &lt;a href=&quot;https://github.com/ymjdz/MATLAB-Codes/blob/master/pv_NED_to_ECEF.m&quot;&gt;
 *     https://github.com/ymjdz/MATLAB-Codes/blob/master/pv_NED_to_ECEF.m
 * &lt;/a&gt;
 */
<span class="fc" id="L37">public class NEDtoECEFPositionVelocityConverter {</span>

    /**
     * The equatorial radius of WGS84 ellipsoid (6378137 m) defining Earth's shape.
     */
    public static final double EARTH_EQUATORIAL_RADIUS_WGS84 = Constants.EARTH_EQUATORIAL_RADIUS_WGS84;

    /**
     * Earth eccentricity as defined on the WGS84 ellipsoid.
     */
    public static final double EARTH_ECCENTRICITY = Constants.EARTH_ECCENTRICITY;

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param sourcePosition      source position resolved on NED frame.
     * @param sourceVelocity      source velocity resolved on NED frame.
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    public void convert(final NEDPosition sourcePosition, final NEDVelocity sourceVelocity,
                        final ECEFPosition destinationPosition, final ECEFVelocity destinationVelocity) {
<span class="fc" id="L62">        convertNEDtoECEF(sourcePosition, sourceVelocity, destinationPosition, destinationVelocity);</span>
<span class="fc" id="L63">    }</span>

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param latitude            latitude expressed in radians (rad).
     * @param longitude           longitude expressed in radians (rad).
     * @param height              height expressed in meters (m).
     * @param vn                  north coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param ve                  east coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param vd                  down coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    public void convert(final double latitude, final double longitude, final double height, final double vn,
                        final double ve, final double vd, final ECEFPosition destinationPosition,
                        final ECEFVelocity destinationVelocity) {
<span class="fc" id="L86">        convertNEDtoECEF(latitude, longitude, height, vn, ve, vd, destinationPosition, destinationVelocity);</span>
<span class="fc" id="L87">    }</span>

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param sourcePosition      source position resolved on NED frame.
     * @param sourceVelocity      source velocity resolved on NED frame.
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    public static void convertNEDtoECEF(final NEDPosition sourcePosition,
                                        final NEDVelocity sourceVelocity,
                                        final ECEFPosition destinationPosition,
                                        final ECEFVelocity destinationVelocity) {
<span class="fc" id="L104">        final var latitude = sourcePosition.getLatitude();</span>
<span class="fc" id="L105">        final var longitude = sourcePosition.getLongitude();</span>
<span class="fc" id="L106">        final var height = sourcePosition.getHeight();</span>

<span class="fc" id="L108">        final var vn = sourceVelocity.getVn();</span>
<span class="fc" id="L109">        final var ve = sourceVelocity.getVe();</span>
<span class="fc" id="L110">        final var vd = sourceVelocity.getVd();</span>

<span class="fc" id="L112">        convertNEDtoECEF(latitude, longitude, height, vn, ve, vd, destinationPosition, destinationVelocity);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Converts curvilinear to cartesian position and velocity resolving axes
     * from NED to ECEF.
     *
     * @param latitude            latitude expressed in radians (rad).
     * @param longitude           longitude expressed in radians (rad).
     * @param height              height expressed in meters (m).
     * @param vn                  north coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param ve                  east coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param vd                  down coordinate of velocity of body frame expressed
     *                            in meters per second (m/s).
     * @param destinationPosition instance where position resolved on ECEF frame will
     *                            be stored.
     * @param destinationVelocity instance where velocity resolved on ECEF frame will
     *                            be stored.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    public static void convertNEDtoECEF(final double latitude, final double longitude, final double height,
                                        final double vn, final double ve, final double vd,
                                        final ECEFPosition destinationPosition,
                                        final ECEFVelocity destinationVelocity) {
        try {

            // Calculate transverse radius of curvature using (2.105)
<span class="fc" id="L141">            final var re = EARTH_EQUATORIAL_RADIUS_WGS84</span>
<span class="fc" id="L142">                    / Math.sqrt(1.0 - Math.pow(EARTH_ECCENTRICITY * Math.sin(latitude), 2.0));</span>

            // Convert position using (2.112)
<span class="fc" id="L145">            final var cosLat = Math.cos(latitude);</span>
<span class="fc" id="L146">            final var sinLat = Math.sin(latitude);</span>
<span class="fc" id="L147">            final var cosLong = Math.cos(longitude);</span>
<span class="fc" id="L148">            final var sinLong = Math.sin(longitude);</span>

<span class="fc" id="L150">            final var x = (re + height) * cosLat * cosLong;</span>
<span class="fc" id="L151">            final var y = (re + height) * cosLat * sinLong;</span>
<span class="fc" id="L152">            final var z = ((1.0 - EARTH_ECCENTRICITY * EARTH_ECCENTRICITY) * re + height) * sinLat;</span>

<span class="fc" id="L154">            destinationPosition.setCoordinates(x, y, z);</span>

            // Calculate NED to ECEF coordinate transformation matrix
<span class="fc" id="L157">            final var cne = CoordinateTransformation.nedToEcefMatrix(latitude, longitude);</span>

            // Transform velocity using (2.73)
<span class="fc" id="L160">            final var vEbn = new Matrix(NEDFrame.NUM_VELOCITY_COORDINATES, 1);</span>
<span class="fc" id="L161">            vEbn.setElementAtIndex(0, vn);</span>
<span class="fc" id="L162">            vEbn.setElementAtIndex(1, ve);</span>
<span class="fc" id="L163">            vEbn.setElementAtIndex(2, vd);</span>

<span class="fc" id="L165">            final var vEbe = cne.multiplyAndReturnNew(vEbn);</span>
<span class="fc" id="L166">            final var vx = vEbe.getElementAtIndex(0);</span>
<span class="fc" id="L167">            final var vy = vEbe.getElementAtIndex(1);</span>
<span class="fc" id="L168">            final var vz = vEbe.getElementAtIndex(2);</span>

<span class="fc" id="L170">            destinationVelocity.setCoordinates(vx, vy, vz);</span>
<span class="nc" id="L171">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>