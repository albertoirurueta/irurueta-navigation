<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GNSSLeastSquaresPositionAndVelocityEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.gnss</a> &gt; <span class="el_source">GNSSLeastSquaresPositionAndVelocityEstimator.java</span></div><h1>GNSSLeastSquaresPositionAndVelocityEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.gnss;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.ECEFPosition;
import com.irurueta.navigation.frames.ECEFVelocity;
import com.irurueta.navigation.frames.NEDPosition;
import com.irurueta.navigation.frames.NEDVelocity;
import com.irurueta.navigation.frames.converters.ECEFtoNEDPositionVelocityConverter;
import com.irurueta.navigation.frames.converters.NEDtoECEFPositionVelocityConverter;
import com.irurueta.navigation.geodesic.Constants;

import java.util.Collection;

/**
 * Calculates position, velocity, clock offset and clock drift using
 * unweighted iterated least squares.
 * Separate calculations are implemented for position and clock offset and
 * for velocity and clock drift.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multi-sensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * &lt;a href=&quot;https://github.com/ymjdz/MATLAB-Codes/blob/master/GNSS_LS_position_velocity.m&quot;&gt;
 *     https://github.com/ymjdz/MATLAB-Codes/blob/master/GNSS_LS_position_velocity.m
 * &lt;/a&gt;
 */
public class GNSSLeastSquaresPositionAndVelocityEstimator {

    /**
     * Minimum number of measurements required to obtain a solution.
     */
    public static final int MIN_MEASUREMENTS = 4;

    /**
     * Default threshold to determine when convergence has been reached.
     */
    public static final double CONVERGENCE_THRESHOLD = 1e-4;

    /**
     * Speed of light in the vacuum expressed in meters per second (m/s).
     */
    public static final double SPEED_OF_LIGHT = Constants.SPEED_OF_LIGHT;

    /**
     * Earth rotation rate expressed in radians per second (rad/s).
     */
    public static final double EARTH_ROTATION_RATE = Constants.EARTH_ROTATION_RATE;

    /**
     * Number of components of predicted state.
     */
    private static final int STATE_COMPONENTS = ECEFPosition.COMPONENTS + 1;

    /**
     * Number of elements of position, velocity, etc.
     */
    private static final int ELEMS = ECEFPosition.COMPONENTS;

    /**
     * Number of elements of position minus one.
     */
    private static final int ELEMS_MINUS_ONE = ELEMS - 1;

    /**
     * GNSS measurements of a collection of satellites.
     */
    private Collection&lt;GNSSMeasurement&gt; measurements;

    /**
     * Previously predicted ECEF user position and velocity.
     */
    private ECEFPositionAndVelocity priorPositionAndVelocity;

    /**
     * Listener to notify events raised by this instance.
     */
    private GNSSLeastSquaresPositionAndVelocityEstimatorListener listener;

    /**
     * Threshold to determine when convergence has been reached.
     */
<span class="fc" id="L100">    private double convergenceThreshold = CONVERGENCE_THRESHOLD;</span>

    /**
     * Indicates whether estimation is currently running.
     */
    private boolean running;

    /**
     * Internal matrix to be reused containing frame rotation during signal transit
     * time.
     */
    private final Matrix cei;

    /**
     * Predicted state to be reused.
     */
    private final Matrix xPred;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp1;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp2;

    /**
     * Estimated state to be reused.
     */
    private final Matrix xEst;

    /**
     * Contains square representation of measurement or geometry matrix.
     */
    private final Matrix hSqr;

    /**
     * Inverse of the square representation of measurement or geometry matrix.
     */
    private final Matrix invHSqr;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp3;

    /**
     * Skew symmetric matrix of Earth rotation rate.
     */
    private final Matrix omegaIe;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp4;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp5;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp6;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp7;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp8;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp9;

    /**
     * Temporal matrix to be reused.
     */
    private final Matrix tmp10;

    /**
     * Measurement position to be reused.
     */
    private final Matrix measurementPosition;

    /**
     * Measurement velocity to be reused.
     */
    private final Matrix measurementVelocity;

    /**
     * Predicted velocity to be reused.
     */
    private final Matrix predVelocity;

    /**
     * Result position to be reused.
     */
    private final Matrix resultPosition;

    /**
     * Constructor.
     */
<span class="fc" id="L211">    public GNSSLeastSquaresPositionAndVelocityEstimator() {</span>
<span class="fc" id="L212">        Matrix cxPred = null;</span>
<span class="fc" id="L213">        Matrix ctmp1 = null;</span>
<span class="fc" id="L214">        Matrix ctmp2 = null;</span>
<span class="fc" id="L215">        Matrix cxEst = null;</span>
<span class="fc" id="L216">        Matrix chSqr = null;</span>
<span class="fc" id="L217">        Matrix cinvHSqr = null;</span>
<span class="fc" id="L218">        Matrix ctmp3 = null;</span>
<span class="fc" id="L219">        Matrix comegaIe = null;</span>
<span class="fc" id="L220">        Matrix ccei = null;</span>
<span class="fc" id="L221">        Matrix ctmp4 = null;</span>
<span class="fc" id="L222">        Matrix ctmp5 = null;</span>
<span class="fc" id="L223">        Matrix ctmp6 = null;</span>
<span class="fc" id="L224">        Matrix ctmp7 = null;</span>
<span class="fc" id="L225">        Matrix ctmp8 = null;</span>
<span class="fc" id="L226">        Matrix ctmp9 = null;</span>
<span class="fc" id="L227">        Matrix ctmp10 = null;</span>
<span class="fc" id="L228">        Matrix cmeasurementPosition = null;</span>
<span class="fc" id="L229">        Matrix cmeasurementVelocity = null;</span>
<span class="fc" id="L230">        Matrix cpredVelocity = null;</span>
<span class="fc" id="L231">        Matrix cresultPosition = null;</span>
        try {
<span class="fc" id="L233">            ccei = Matrix.identity(ELEMS, ELEMS);</span>
<span class="fc" id="L234">            cxPred = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L235">            ctmp1 = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L236">            ctmp2 = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L237">            cxEst = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L238">            chSqr = new Matrix(STATE_COMPONENTS, STATE_COMPONENTS);</span>
<span class="fc" id="L239">            cinvHSqr = new Matrix(STATE_COMPONENTS, STATE_COMPONENTS);</span>
<span class="fc" id="L240">            ctmp3 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L241">            comegaIe = Utils.skewMatrix(new double[]{0.0, 0.0, EARTH_ROTATION_RATE});</span>
<span class="fc" id="L242">            ctmp4 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L243">            ctmp5 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L244">            ctmp6 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L245">            ctmp7 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L246">            ctmp8 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L247">            ctmp9 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L248">            ctmp10 = new Matrix(STATE_COMPONENTS, 1);</span>
<span class="fc" id="L249">            cmeasurementPosition = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L250">            cmeasurementVelocity = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L251">            cpredVelocity = new Matrix(ELEMS, 1);</span>
<span class="fc" id="L252">            cresultPosition = new Matrix(ELEMS, 1);</span>
<span class="nc" id="L253">        } catch (WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L255">        }</span>

<span class="fc" id="L257">        this.cei = ccei;</span>
<span class="fc" id="L258">        this.xPred = cxPred;</span>
<span class="fc" id="L259">        this.tmp1 = ctmp1;</span>
<span class="fc" id="L260">        this.tmp2 = ctmp2;</span>
<span class="fc" id="L261">        this.xEst = cxEst;</span>
<span class="fc" id="L262">        this.hSqr = chSqr;</span>
<span class="fc" id="L263">        this.invHSqr = cinvHSqr;</span>
<span class="fc" id="L264">        this.tmp3 = ctmp3;</span>
<span class="fc" id="L265">        this.omegaIe = comegaIe;</span>
<span class="fc" id="L266">        this.tmp4 = ctmp4;</span>
<span class="fc" id="L267">        this.tmp5 = ctmp5;</span>
<span class="fc" id="L268">        this.tmp6 = ctmp6;</span>
<span class="fc" id="L269">        this.tmp7 = ctmp7;</span>
<span class="fc" id="L270">        this.tmp8 = ctmp8;</span>
<span class="fc" id="L271">        this.tmp9 = ctmp9;</span>
<span class="fc" id="L272">        this.tmp10 = ctmp10;</span>
<span class="fc" id="L273">        this.measurementPosition = cmeasurementPosition;</span>
<span class="fc" id="L274">        this.measurementVelocity = cmeasurementVelocity;</span>
<span class="fc" id="L275">        this.predVelocity = cpredVelocity;</span>
<span class="fc" id="L276">        this.resultPosition = cresultPosition;</span>
<span class="fc" id="L277">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurements of a collection of satellites.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(final Collection&lt;GNSSMeasurement&gt; measurements) {
<span class="fc" id="L286">        this();</span>
        try {
<span class="fc" id="L288">            setMeasurements(measurements);</span>
<span class="nc" id="L289">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L291">        }</span>
<span class="fc" id="L292">    }</span>

    /**
     * Constructor.
     *
     * @param measurements             GNSS measurements of a collection of satellites.
     * @param priorPositionAndVelocity previously predicted ECEF user position and
     *                                 velocity.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final ECEFPositionAndVelocity priorPositionAndVelocity) {
<span class="fc" id="L305">        this();</span>
        try {
<span class="fc" id="L307">            setMeasurements(measurements);</span>
<span class="fc" id="L308">            setPriorPositionAndVelocity(priorPositionAndVelocity);</span>
<span class="nc" id="L309">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L311">        }</span>
<span class="fc" id="L312">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurement of a collection of satellites.
     * @param priorEstimation  previously predicted GNSS estimation.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final GNSSEstimation priorEstimation) {
<span class="fc" id="L324">        this();</span>
        try {
<span class="fc" id="L326">            setMeasurements(measurements);</span>
<span class="fc" id="L327">            setPriorPositionAndVelocityFromEstimation(priorEstimation);</span>
<span class="nc" id="L328">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L330">        }</span>
<span class="fc" id="L331">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener notifying events raised by this instance.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L340">        this();</span>
        try {
<span class="fc" id="L342">            setListener(listener);</span>
<span class="nc" id="L343">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L345">        }</span>
<span class="fc" id="L346">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurements of a collection of satellites.
     * @param listener     listener notifying events raised by this instance.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L358">        this(measurements);</span>
        try {
<span class="fc" id="L360">            setListener(listener);</span>
<span class="nc" id="L361">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L363">        }</span>
<span class="fc" id="L364">    }</span>

    /**
     * Constructor.
     *
     * @param measurements             GNSS measurements of a collection of satellites.
     * @param priorPositionAndVelocity previously predicted ECEF user position and
     *                                 velocity.
     * @param listener                 listener notifying events raised by this
     *                                 instance.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final ECEFPositionAndVelocity priorPositionAndVelocity,
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L380">        this(measurements, priorPositionAndVelocity);</span>
        try {
<span class="fc" id="L382">            setListener(listener);</span>
<span class="nc" id="L383">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L385">        }</span>
<span class="fc" id="L386">    }</span>

    /**
     * Constructor.
     *
     * @param measurements GNSS measurement of a collection of satellites.
     * @param priorEstimation  previously predicted GNSS estimation.
     * @param listener     listener notifying events raised by this instance.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimator(
            final Collection&lt;GNSSMeasurement&gt; measurements,
            final GNSSEstimation priorEstimation,
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) {
<span class="fc" id="L400">        this(measurements, priorEstimation);</span>
        try {
<span class="fc" id="L402">            setListener(listener);</span>
<span class="nc" id="L403">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L405">        }</span>
<span class="fc" id="L406">    }</span>

    /**
     * Gets GNSS measurements of a collection of satellites.
     *
     * @return GNSS measurements of a collection of satellites.
     */
    public Collection&lt;GNSSMeasurement&gt; getMeasurements() {
<span class="fc" id="L414">        return measurements;</span>
    }

    /**
     * Sets GNSS measurements of a collection of satellites.
     *
     * @param measurements GNSS measurements of a collection of satellites.
     * @throws IllegalArgumentException if less than 4 measurements are provided.
     * @throws LockedException          if this estimator is already running.
     */
    public void setMeasurements(final Collection&lt;GNSSMeasurement&gt; measurements) throws LockedException {
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L426">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (!isValidMeasurements(measurements)) {</span>
<span class="fc" id="L429">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L432">        this.measurements = measurements;</span>
<span class="fc" id="L433">    }</span>

    /**
     * Gets previously predicted ECEF user position and velocity.
     *
     * @return previously predicted ECEF user position and velocity.
     */
    public ECEFPositionAndVelocity getPriorPositionAndVelocity() {
<span class="fc" id="L441">        return priorPositionAndVelocity;</span>
    }

    /**
     * Sets previously predicted ECEF user position and velocity.
     *
     * @param priorPositionAndVelocity previously predicted ECEF user position and
     *                                 velocity.
     * @throws LockedException if this estimator is already running.
     */
    public void setPriorPositionAndVelocity(
            final ECEFPositionAndVelocity priorPositionAndVelocity) throws LockedException {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L454">            throw new LockedException();</span>
        }

<span class="fc" id="L457">        this.priorPositionAndVelocity = priorPositionAndVelocity;</span>
<span class="fc" id="L458">    }</span>

    /**
     * Sets previously predicted ECEF user position and velocity from a previous
     * predicted result.
     *
     * @param priorEstimation previously predicted GNSS estimation.
     * @throws LockedException if this estimator is already running.
     */
    public void setPriorPositionAndVelocityFromEstimation(
            final GNSSEstimation priorEstimation) throws LockedException {
<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L470">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L473" title="All 2 branches covered.">        priorPositionAndVelocity = priorEstimation != null ? priorEstimation.getPositionAndVelocity() : null;</span>
<span class="fc" id="L474">    }</span>

    /**
     * Gets listener to notify events raised by this instance.
     *
     * @return listener to notify events raised by this instance.
     */
    public GNSSLeastSquaresPositionAndVelocityEstimatorListener getListener() {
<span class="fc" id="L482">        return listener;</span>
    }

    /**
     * Sets listener to notify events raised by this instance.
     *
     * @param listener listener to notify events raised by this instance.
     * @throws LockedException if this estimator is already running.
     */
    public void setListener(
            final GNSSLeastSquaresPositionAndVelocityEstimatorListener listener) throws LockedException {
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L494">            throw new LockedException();</span>
        }
<span class="fc" id="L496">        this.listener = listener;</span>
<span class="fc" id="L497">    }</span>

    /**
     * Gets threshold to determine when convergence has been reached.
     *
     * @return threshold to determine when convergence has been reached.
     */
    public double getConvergenceThreshold() {
<span class="fc" id="L505">        return convergenceThreshold;</span>
    }

    /**
     * Sets threshold to determine when convergence has been reached.
     *
     * @param convergenceThreshold threshold to determine when convergence has
     *                             been reached.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided threshold is zero or negative.
     */
    public void setConvergenceThreshold(final double convergenceThreshold) throws LockedException,
            IllegalArgumentException {
<span class="fc bfc" id="L518" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L519">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">        if (convergenceThreshold &lt;= 0.0) {</span>
<span class="nc" id="L522">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L525">        this.convergenceThreshold = convergenceThreshold;</span>
<span class="fc" id="L526">    }</span>

    /**
     * Indicates whether this estimator is ready to start the estimation.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isReady() {
<span class="fc" id="L534">        return isValidMeasurements(measurements);</span>
    }

    /**
     * Indicates whether this estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L543">        return running;</span>
    }

    /**
     * Indicates whether provided measurements are valid or not.
     *
     * @param gnssMeasurements measurements to be checked.
     * @return true if at least 4 measurements are provided, false otherwise.
     */
    public static boolean isValidMeasurements(final Collection&lt;GNSSMeasurement&gt; gnssMeasurements) {
<span class="fc bfc" id="L553" title="All 4 branches covered.">        return gnssMeasurements != null &amp;&amp; gnssMeasurements.size() &gt;= MIN_MEASUREMENTS;</span>
    }

    /**
     * Estimates new ECEF user position and velocity as well as clock
     * offset and drift.
     *
     * @param result instance where result data will be stored.
     * @throws NotReadyException if estimator is not ready to start estimation.
     * @throws LockedException   if estimator is already running.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    public void estimate(final GNSSEstimation result) throws NotReadyException, LockedException, GNSSException {
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L568">            throw new NotReadyException();</span>
        }
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L571">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L575">            running = true;</span>

<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L578">                listener.onEstimateStart(this);</span>
            }

            // if no prior position and velocity is available, assume that
            // we are at latitude,longitude equal to the average of satellite
            // measurements, at Earth's surface (height = 0) and with zero velocity.
<span class="fc" id="L584">            initializePriorPositionAndVelocityIfNeeded();</span>

            // POSITION AND CLOCK OFFSET

            // Setup predicted state
<span class="fc" id="L589">            final var priorX = priorPositionAndVelocity.getX();</span>
<span class="fc" id="L590">            final var priorY = priorPositionAndVelocity.getY();</span>
<span class="fc" id="L591">            final var priorZ = priorPositionAndVelocity.getZ();</span>

<span class="fc" id="L593">            xPred.setElementAtIndex(0, priorX);</span>
<span class="fc" id="L594">            xPred.setElementAtIndex(1, priorY);</span>
<span class="fc" id="L595">            xPred.setElementAtIndex(2, priorZ);</span>
<span class="fc" id="L596">            xPred.setElementAtIndex(3, 0.0);</span>

<span class="fc" id="L598">            final var numMeasurements = measurements.size();</span>
<span class="fc" id="L599">            final var predMeas = new Matrix(numMeasurements, 1);</span>
<span class="fc" id="L600">            final var h = new Matrix(numMeasurements, STATE_COMPONENTS);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            for (var i = 0; i &lt; numMeasurements; i++) {</span>
<span class="fc" id="L602">                h.setElementAt(i, 3, 1.0);</span>
            }

<span class="fc" id="L605">            final var hTrans = new Matrix(STATE_COMPONENTS, numMeasurements);</span>
<span class="fc" id="L606">            final var hTmp1 = new Matrix(STATE_COMPONENTS, numMeasurements);</span>
<span class="fc" id="L607">            final var deltaPseudoRange = new Matrix(numMeasurements, 1);</span>

            // Repeat until convergence
<span class="fc" id="L610">            var testConvergence = 1.0;</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">            while (testConvergence &gt; convergenceThreshold) {</span>

                // Loop measurements
<span class="fc" id="L614">                var j = 0;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">                for (final var measurement : measurements) {</span>

                    // Predict approx range
<span class="fc" id="L618">                    final var measX = measurement.getX();</span>
<span class="fc" id="L619">                    final var measY = measurement.getY();</span>
<span class="fc" id="L620">                    final var measZ = measurement.getZ();</span>

<span class="fc" id="L622">                    var deltaRx = measX - priorX;</span>
<span class="fc" id="L623">                    var deltaRy = measY - priorY;</span>
<span class="fc" id="L624">                    var deltaRz = measZ - priorZ;</span>
<span class="fc" id="L625">                    final var approxRange = norm(deltaRx, deltaRy, deltaRz);</span>

                    // Calculate frame rotation during signal transit time using (8.36)
<span class="fc" id="L628">                    final var ceiValue = EARTH_ROTATION_RATE * approxRange / SPEED_OF_LIGHT;</span>
<span class="fc" id="L629">                    cei.setElementAt(0, 1, ceiValue);</span>
<span class="fc" id="L630">                    cei.setElementAt(1, 0, -ceiValue);</span>

                    // Predict pseudo-range using (9.143)
<span class="fc" id="L633">                    tmp1.setElementAtIndex(0, measX);</span>
<span class="fc" id="L634">                    tmp1.setElementAtIndex(1, measY);</span>
<span class="fc" id="L635">                    tmp1.setElementAtIndex(2, measZ);</span>

<span class="fc" id="L637">                    cei.multiply(tmp1, tmp2);</span>

<span class="fc" id="L639">                    deltaRx = tmp2.getElementAtIndex(0) - xPred.getElementAtIndex(0);</span>
<span class="fc" id="L640">                    deltaRy = tmp2.getElementAtIndex(1) - xPred.getElementAtIndex(1);</span>
<span class="fc" id="L641">                    deltaRz = tmp2.getElementAtIndex(2) - xPred.getElementAtIndex(2);</span>
<span class="fc" id="L642">                    final var range = norm(deltaRx, deltaRy, deltaRz);</span>

<span class="fc" id="L644">                    final var predictedPseudoRange = range + xPred.getElementAtIndex(3);</span>
<span class="fc" id="L645">                    predMeas.setElementAtIndex(j, predictedPseudoRange);</span>

<span class="fc" id="L647">                    deltaPseudoRange.setElementAtIndex(j, measurement.getPseudoRange() - predictedPseudoRange);</span>

                    // Predict line of sight and deploy in measurement matrix, (9.144)
<span class="fc" id="L650">                    h.setElementAt(j, 0, -deltaRx / range);</span>
<span class="fc" id="L651">                    h.setElementAt(j, 1, -deltaRy / range);</span>
<span class="fc" id="L652">                    h.setElementAt(j, 2, -deltaRz / range);</span>

<span class="fc" id="L654">                    j++;</span>
<span class="fc" id="L655">                }</span>

                // Unweighted least-squares solution, (9.35)/(9.141)
<span class="fc" id="L658">                h.transpose(hTrans);</span>
<span class="fc" id="L659">                hTrans.multiply(h, hSqr);</span>
<span class="fc" id="L660">                Utils.inverse(hSqr, invHSqr);</span>
<span class="fc" id="L661">                invHSqr.multiply(hTrans, hTmp1);</span>
<span class="fc" id="L662">                hTmp1.multiply(deltaPseudoRange, tmp3);</span>

<span class="fc" id="L664">                xPred.add(tmp3, xEst);</span>

                // Test convergence
<span class="fc" id="L667">                testConvergence = predictionError();</span>

                // Set predictions to estimates for next iteration
<span class="fc" id="L670">                xPred.copyFrom(xEst);</span>
<span class="fc" id="L671">            }</span>

            // Set outputs to estimates
<span class="fc" id="L674">            final var resultX = xEst.getElementAtIndex(0);</span>
<span class="fc" id="L675">            final var resultY = xEst.getElementAtIndex(1);</span>
<span class="fc" id="L676">            final var resultZ = xEst.getElementAtIndex(2);</span>
<span class="fc" id="L677">            result.setPositionCoordinates(resultX, resultY, resultZ);</span>

<span class="fc" id="L679">            final var resultClockOffset = xEst.getElementAtIndex(3);</span>
<span class="fc" id="L680">            result.setClockOffset(resultClockOffset);</span>


            // VELOCITY AND CLOCK DRIFT

            // Setup predicted state
<span class="fc" id="L686">            final var priorVx = priorPositionAndVelocity.getVx();</span>
<span class="fc" id="L687">            final var priorVy = priorPositionAndVelocity.getVy();</span>
<span class="fc" id="L688">            final var priorVz = priorPositionAndVelocity.getVz();</span>

<span class="fc" id="L690">            xPred.setElementAtIndex(0, priorVx);</span>
<span class="fc" id="L691">            xPred.setElementAtIndex(1, priorVy);</span>
<span class="fc" id="L692">            xPred.setElementAtIndex(2, priorVz);</span>
<span class="fc" id="L693">            xPred.setElementAtIndex(3, 0.0);</span>

<span class="fc" id="L695">            resultPosition.setElementAtIndex(0, resultX);</span>
<span class="fc" id="L696">            resultPosition.setElementAtIndex(1, resultY);</span>
<span class="fc" id="L697">            resultPosition.setElementAtIndex(2, resultZ);</span>

<span class="fc" id="L699">            final var deltaPseudoRangeRate = new Matrix(numMeasurements, 1);</span>

            // Repeat until convergence
<span class="fc" id="L702">            testConvergence = 1.0;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">            while (testConvergence &gt; convergenceThreshold) {</span>

                // Loop measurements
<span class="fc" id="L706">                var j = 0;</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">                for (final var measurement : measurements) {</span>
                    // Predict approx range
<span class="fc" id="L709">                    final var measX = measurement.getX();</span>
<span class="fc" id="L710">                    final var measY = measurement.getY();</span>
<span class="fc" id="L711">                    final var measZ = measurement.getZ();</span>

<span class="fc" id="L713">                    var deltaRx = measX - resultX;</span>
<span class="fc" id="L714">                    var deltaRy = measY - resultY;</span>
<span class="fc" id="L715">                    var deltaRz = measZ - resultZ;</span>
<span class="fc" id="L716">                    final var approxRange = norm(deltaRx, deltaRy, deltaRz);</span>

                    // Calculate frame rotation during signal transit time using (8.36)
<span class="fc" id="L719">                    final var ceiValue = EARTH_ROTATION_RATE * approxRange / SPEED_OF_LIGHT;</span>
<span class="fc" id="L720">                    cei.setElementAt(0, 1, ceiValue);</span>
<span class="fc" id="L721">                    cei.setElementAt(1, 0, -ceiValue);</span>

                    // Calculate range using (8.35)
<span class="fc" id="L724">                    tmp1.setElementAtIndex(0, measX);</span>
<span class="fc" id="L725">                    tmp1.setElementAtIndex(1, measY);</span>
<span class="fc" id="L726">                    tmp1.setElementAtIndex(2, measZ);</span>

<span class="fc" id="L728">                    cei.multiply(tmp1, tmp2);</span>

<span class="fc" id="L730">                    deltaRx = tmp2.getElementAtIndex(0) - resultX;</span>
<span class="fc" id="L731">                    deltaRy = tmp2.getElementAtIndex(1) - resultY;</span>
<span class="fc" id="L732">                    deltaRz = tmp2.getElementAtIndex(2) - resultZ;</span>
<span class="fc" id="L733">                    final var range = norm(deltaRx, deltaRy, deltaRz);</span>

                    // Calculate line of sight using (8.41)
<span class="fc" id="L736">                    final var uaseX = deltaRx / range;</span>
<span class="fc" id="L737">                    final var uaseY = deltaRy / range;</span>
<span class="fc" id="L738">                    final var uaseZ = deltaRz / range;</span>

                    // Predict pseudo-range rate using (9.143)
<span class="fc" id="L741">                    measurementPosition.setElementAtIndex(0, measX);</span>
<span class="fc" id="L742">                    measurementPosition.setElementAtIndex(1, measY);</span>
<span class="fc" id="L743">                    measurementPosition.setElementAtIndex(2, measZ);</span>

<span class="fc" id="L745">                    final var measVx = measurement.getVx();</span>
<span class="fc" id="L746">                    final var measVy = measurement.getVy();</span>
<span class="fc" id="L747">                    final var measVz = measurement.getVz();</span>

<span class="fc" id="L749">                    measurementVelocity.setElementAtIndex(0, measVx);</span>
<span class="fc" id="L750">                    measurementVelocity.setElementAtIndex(1, measVy);</span>
<span class="fc" id="L751">                    measurementVelocity.setElementAtIndex(2, measVz);</span>

<span class="fc" id="L753">                    omegaIe.multiply(measurementPosition, tmp4);</span>

<span class="fc" id="L755">                    measurementVelocity.add(tmp4, tmp5);</span>

<span class="fc" id="L757">                    cei.multiply(tmp5, tmp6);</span>

<span class="fc" id="L759">                    omegaIe.multiply(resultPosition, tmp7);</span>

<span class="fc" id="L761">                    xPred.getSubmatrix(0, 0, ELEMS_MINUS_ONE, 0, predVelocity);</span>

<span class="fc" id="L763">                    predVelocity.add(tmp7, tmp8);</span>

<span class="fc" id="L765">                    tmp6.subtract(tmp8, tmp9);</span>

<span class="fc" id="L767">                    final var rangeRate = uaseX * tmp9.getElementAtIndex(0) + uaseY * tmp9.getElementAtIndex(1)</span>
<span class="fc" id="L768">                            + uaseZ * tmp9.getElementAtIndex(2);</span>

<span class="fc" id="L770">                    final var predictedPseudoRangeRate = rangeRate + xPred.getElementAtIndex(3);</span>
<span class="fc" id="L771">                    predMeas.setElementAtIndex(j, predictedPseudoRangeRate);</span>

<span class="fc" id="L773">                    deltaPseudoRangeRate.setElementAtIndex(j,</span>
<span class="fc" id="L774">                            measurement.getPseudoRate() - predictedPseudoRangeRate);</span>

                    // Predict line of sight and deploy in measurement matrix, (9.144)
<span class="fc" id="L777">                    h.setElementAt(j, 0, -uaseX);</span>
<span class="fc" id="L778">                    h.setElementAt(j, 1, -uaseY);</span>
<span class="fc" id="L779">                    h.setElementAt(j, 2, -uaseZ);</span>

<span class="fc" id="L781">                    j++;</span>
<span class="fc" id="L782">                }</span>

                // Unweighted least-squares solution, (9.35)/(9.141)
<span class="fc" id="L785">                h.transpose(hTrans);</span>
<span class="fc" id="L786">                hTrans.multiply(h, hSqr);</span>
<span class="fc" id="L787">                Utils.inverse(hSqr, invHSqr);</span>
<span class="fc" id="L788">                invHSqr.multiply(hTrans, hTmp1);</span>
<span class="fc" id="L789">                hTmp1.multiply(deltaPseudoRangeRate, tmp10);</span>

<span class="fc" id="L791">                xPred.add(tmp10, xEst);</span>

                // Test convergence
<span class="fc" id="L794">                testConvergence = predictionError();</span>

                // Set predictions to estimates for next iteration
<span class="fc" id="L797">                xPred.copyFrom(xEst);</span>
<span class="fc" id="L798">            }</span>

            // Set outputs to estimates
<span class="fc" id="L801">            final var resultVx = xEst.getElementAtIndex(0);</span>
<span class="fc" id="L802">            final var resultVy = xEst.getElementAtIndex(1);</span>
<span class="fc" id="L803">            final var resultVz = xEst.getElementAtIndex(2);</span>
<span class="fc" id="L804">            result.setVelocityCoordinates(resultVx, resultVy, resultVz);</span>

<span class="fc" id="L806">            final var resultClockDrift = xEst.getElementAtIndex(3);</span>
<span class="fc" id="L807">            result.setClockDrift(resultClockDrift);</span>

<span class="nc" id="L809">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L810">            throw new GNSSException(e);</span>
        } finally {
<span class="fc bfc" id="L812" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L813">                listener.onEstimateEnd(this);</span>
            }

<span class="fc" id="L816">            running = false;</span>
        }
<span class="fc" id="L818">    }</span>

    /**
     * Estimates new ECEF user position and velocity as well as clock
     * offset and drift.
     *
     * @return new ECEF user position and velocity, and clock offset and drift.
     * @throws NotReadyException if estimator is not ready to start estimation.
     * @throws LockedException   if estimator is already running.
     * @throws GNSSException     if estimation fails due to numerical instabilities.
     */
    public GNSSEstimation estimate() throws NotReadyException, LockedException, GNSSException {
<span class="fc" id="L830">        final var result = new GNSSEstimation();</span>
<span class="fc" id="L831">        estimate(result);</span>
<span class="fc" id="L832">        return result;</span>
    }

    /**
     * Initializes prior position and velocity if not set, assuming that
     * user is located at the average latitude, longitude of all provided
     * satellite measurements, at Earth's surface (height = 0) and with zero velocity.
     */
    private void initializePriorPositionAndVelocityIfNeeded() {
<span class="fc bfc" id="L841" title="All 2 branches covered.">        if (priorPositionAndVelocity != null) {</span>
<span class="fc" id="L842">            return;</span>
        }

<span class="fc" id="L845">        var numMeasurements = measurements.size();</span>
<span class="fc" id="L846">        final var nedPosition = new NEDPosition();</span>
<span class="fc" id="L847">        final var nedVelocity = new NEDVelocity();</span>

<span class="fc" id="L849">        final var ecefPosition = new ECEFPosition();</span>
<span class="fc" id="L850">        final var ecefVelocity = new ECEFVelocity();</span>

<span class="fc" id="L852">        var userLatitude = 0.0;</span>
<span class="fc" id="L853">        var userLongitude = 0.0;</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">        for (final var measurement : measurements) {</span>
<span class="fc" id="L855">            measurement.getEcefPosition(ecefPosition);</span>
<span class="fc" id="L856">            measurement.getEcefVelocity(ecefVelocity);</span>
<span class="fc" id="L857">            ECEFtoNEDPositionVelocityConverter.convertECEFtoNED(ecefPosition, ecefVelocity, nedPosition, nedVelocity);</span>

<span class="fc" id="L859">            final var satLatitude = nedPosition.getLatitude();</span>
<span class="fc" id="L860">            final var satLongitude = nedPosition.getLongitude();</span>

<span class="fc" id="L862">            userLatitude += satLatitude / numMeasurements;</span>
<span class="fc" id="L863">            userLongitude += satLongitude / numMeasurements;</span>
<span class="fc" id="L864">        }</span>

<span class="fc" id="L866">        nedPosition.setCoordinates(userLatitude, userLongitude, 0.0);</span>
<span class="fc" id="L867">        nedVelocity.setCoordinates(0.0, 0.0, 0.0);</span>

<span class="fc" id="L869">        NEDtoECEFPositionVelocityConverter.convertNEDtoECEF(nedPosition, nedVelocity, ecefPosition, ecefVelocity);</span>

<span class="fc" id="L871">        priorPositionAndVelocity = new ECEFPositionAndVelocity(ecefPosition, ecefVelocity);</span>
<span class="fc" id="L872">    }</span>

    /**
     * Computes norm of provided coordinates.
     *
     * @param x x coordinate.
     * @param y y coordinate.
     * @param z z coordinate.
     * @return computed norm.
     */
    private static double norm(final double x, final double y, final double z) {
<span class="fc" id="L883">        return Math.sqrt(x * x + y * y + z * z);</span>
    }

    /**
     * Computes norm of error between estimated state
     * and predicted state.
     *
     * @return norm of error.
     */
    private double predictionError() {
<span class="fc" id="L893">        var sqrPredictionError = 0.0;</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">        for (var i = 0; i &lt; STATE_COMPONENTS; i++) {</span>
<span class="fc" id="L895">            final var diff = xEst.getElementAtIndex(i) - xPred.getElementAtIndex(i);</span>
<span class="fc" id="L896">            sqrPredictionError += diff * diff;</span>
        }
<span class="fc" id="L898">        return Math.sqrt(sqrPredictionError);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>